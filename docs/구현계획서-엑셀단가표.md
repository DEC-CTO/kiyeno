# 엑셀 단가표 로드 기능 구현 계획

## 개요

외부 엑셀 단가표를 로드하여 간소화된 일위대가로 저장하고, 기존 상세 일위대가 방식과 **완벽 분리**하여 병행 운영하는 시스템 구현.

**핵심 원칙**: 기존 코드 수정 최소화, 별도 모듈/테이블/UI로 완전 분리

---

## 단계별 구현 태스크

### Phase 1: 메인 화면 UI 변경

**파일**: `public/index.html` (라인 94-120), `public/css/styles.css`

**작업 내용**:
1. 기존 3개 버튼 위에 "일위대가 방식" 섹션 라벨 추가
2. 구분선 추가
3. "간소화 방식 (엑셀 단가표)" 섹션 라벨 추가
4. 2개 신규 버튼 추가:
   - `[엑셀 단가표 관리]` (id: `btnExcelUnitPriceManagement`, 아이콘: `fa-file-excel`)
   - `[엑셀 벽체타입 관리]` (id: `btnExcelWallTypeManagement`, 아이콘: `fa-th-list`)
5. CSS 스타일링 (섹션 라벨, 구분선, 버튼 색상)

**현재 구조** (index.html:94-120):
```html
<button class="btn btn-green" id="materialManageBtn">자재 관리</button>
<button class="btn btn-purple" id="wallTypeManageBtn">벽체 타입 관리</button>
<button class="btn btn-orange" id="unitPriceManageBtn">일위대가 관리</button>
```

**변경 후 구조**:
```
▸ 일위대가 방식
  [자재 관리]  [벽체 타입 관리]  [일위대가 관리]
─────────────────────────────────────────────
▸ 간소화 방식 (엑셀 단가표)
  [엑셀 단가표 관리]  [엑셀 벽체타입 관리]
```

---

### Phase 2: 별도 IndexedDB 생성 (`KiyenoExcelDB` v1)

**파일**: `public/js/modules/excelUnitPriceImporter.js` (신규, Phase 3과 통합)

**설계 결정**: 기존 `KiyenoMaterialsDB` (v3)는 **수정하지 않음**. 별도 DB로 완벽 분리.

| 항목 | 기존 DB | 엑셀 DB |
|------|---------|---------|
| DB명 | `KiyenoMaterialsDB` | `KiyenoExcelDB` |
| 버전 | v3 (변경 없음) | v1 (신규) |
| 테이블 | materials, unitPrices, wallTypeMasters | importedUnitPrices, excelWallTypes |
| 관리 파일 | priceDatabase.js, unitPriceManager.js | excelUnitPriceImporter.js (신규) |

**테이블 1: `importedUnitPrices`**
```javascript
// 엑셀에서 가져온 간소화 일위대가
{
  id: 'imp_1705234567890',       // PK
  key: 'c-stud_65형',           // 인덱스 (품명_규격 소문자)
  location: '벽',               // 부위 (A열: "가설벽", "벽" 등)
  item: 'C-STUD',               // 인덱스 - 품명 (B열)
  spec: '65형',                 // 인덱스 - 규격 (C열)
  unit: 'M2',                   // 단위 (D열)
  thickness: 65,                // 두께 (E열, mm)
  quantity: 1,                  // 수량 (F열)
  materialPrice: 7514,          // 자재비 (G열)
  laborPrice: 7000,             // 노무비 (H열)
  totalPrice: 14514,            // 단가 (I열, 없으면 자재비+노무비)
  materialWorkType: '',         // 자재공종 (J열)
  laborWorkType: '',            // 노무공종 (K열)
  importedAt: 'ISO8601',        // 인덱스 - 최초 가져온 시간
  updatedAt: 'ISO8601'          // 마지막 업데이트 시간
}
```

**테이블 2: `excelWallTypes`**

기존 `wallTypeMasters`와 **동일한 레이어 구조** 사용 (기본 12개 + 동적 추가 가능).

```javascript
// 엑셀 일위대가 기반 벽체타입
{
  id: 'ewt_1705234567890',      // PK
  name: 'W-01',                 // 인덱스 - 타입명
  source: 'excel',              // 'excel' 고정 (기존 'detailed'와 구분)

  // === 기본 12개 레이어 (기존 wallTypeMasters와 동일 필드명) ===
  layer3_1: '',                 // 좌측마감 Layer3 (importedUnitPriceId)
  layer2_1: '',                 // 좌측마감 Layer2
  layer1_1: '',                 // 좌측마감 Layer1
  column1: '',                  // 구조체
  infill: '',                   // 단열재
  layer1_2: '',                 // 우측마감 Layer1
  layer2_2: '',                 // 우측마감 Layer2
  layer3_2: '',                 // 우측마감 Layer3
  column2: '',                  // 옵션1
  channel: '',                  // 옵션2
  runner: '',                   // 옵션3
  steelPlate: '',               // 옵션4

  // === 12개 초과 시 동적 추가 레이어 ===
  extraLayers: [
    // { field: 'extra_1', label: '추가1', unitPriceId: '' }
  ],

  thickness: 0,                 // 총 두께 (mm)
  totalMaterialPrice: 11224,
  totalLaborPrice: 10542,
  totalPrice: 21766,
  createdAt: 'ISO8601',         // 인덱스
  updatedAt: 'ISO8601'
}
```

**각 레이어 필드 값**: `importedUnitPrices`의 `id` 값을 저장 (예: `'imp_1705234567890'`)

**기존 wallTypeMasters와의 차이점**:
| 항목 | wallTypeMasters | excelWallTypes |
|------|----------------|----------------|
| 레이어 참조 | materialId 또는 unitPriceId | importedUnitPriceId |
| 동적 확장 | 고정 12개 | 기본 12개 + extraLayers 배열 |
| 가격 계산 | 상세 구성품 소요량 | 자재비/노무비 단순 합산 |
| DB | KiyenoMaterialsDB | KiyenoExcelDB |

**장점**: `priceDatabase.js`, `unitPriceManager.js` 수정 0줄. 기존 시스템에 영향 없음.

---

### Phase 3: 엑셀 파싱 모듈

**파일**: `public/js/modules/excelUnitPriceImporter.js` (신규)

**작업 내용**:
1. SheetJS(XLSX) 라이브러리를 사용한 엑셀 파싱
2. 헤더 인식 (부위, 품명, 규격, 단위, 두께, 수량, 자재비, 노무비, 단가, 자재공종, 노무공종)
3. 키 생성: `key = (품명 + "_" + 규격).toLowerCase().replace(/\s+/g, '')`
4. DB 저장 (upsert: 동일 key 존재 시 업데이트)
5. CRUD 함수:
   - `parseUnitPriceExcel(file)` → 파싱된 데이터 배열 반환
   - `saveImportedUnitPrices(unitPrices)` → DB upsert
   - `getAllImportedUnitPrices()` → 전체 조회
   - `getImportedUnitPriceByKey(key)` → 키로 조회
   - `updateImportedUnitPrice(id, data)` → 수정
   - `deleteImportedUnitPrice(id)` → 삭제
   - `clearAllImportedUnitPrices()` → 전체 삭제

**의존성**: SheetJS (이미 index.html에 포함됨)

---

### Phase 4: 엑셀 단가표 관리 모달

**파일**: `public/js/modules/excelPriceManager.js` (신규)

**작업 내용**:
1. `openExcelUnitPriceModal()` → 메인 모달 (createSubModal 사용, disableEscapeKey: true)
2. 모달 레이아웃:
   - 커스텀 헤더 (제목 + X 닫기 버튼)
   - 상단 툴바: [파일선택 + 업로드] [엑셀 내보내기] [행 추가] [전체 삭제]
   - 검색 입력창 (실시간 필터링, 디바운스 300ms)
   - 일위대가 목록 테이블 (NO, 부위, 품명, 규격, 단위, 두께, 수량, 자재비, 노무비, 합계, 자재공종, 노무공종)
   - 상태 표시줄 (총 N개 항목, 마지막 업로드 시간)
3. **2단계 그룹핑**: 부위(1차, 가설벽→벽→나머지 가나다순) → 품명(2차, 가나다순)
4. **인라인 셀 편집** (엑셀 스타일, 셀 크기 고정):
   - 셀 클릭 → input 태그 인라인 삽입 (셀 크기 고정, 내부에서 편집)
   - 편집 가능 필드: 부위, 품명, 규격, 단위, 두께, 수량, 자재비, 노무비, 자재공종, 노무공종
   - 편집 불가 필드: NO, 합계 (자동계산)
   - 품명/규격 편집 시 key 자동 재생성 + 테이블 리렌더 (그룹핑 반영)
   - blur 또는 Enter → DB 즉시 업데이트 (`updateImportedUnitPrice()`)
   - Escape → 편집 취소 (원래 값 복원)
   - 합계 컬럼: 자재비/노무비 수정 시 자동 재계산
   - 숫자 필드: 천단위 콤마 표시, 두께는 소수점 허용
5. **엑셀 재업로드** (upsert): Phase 3의 `saveImportedUnitPrices()`가 key 기준 자동 업데이트
6. **엑셀 내보내기**: 현재 DB 데이터를 SheetJS로 .xlsx 파일 생성 및 다운로드
   - 컬럼 순서: 부위, 품명, 규격, 단위, 두께, 수량, 자재비, 노무비, 단가, 자재공종, 노무공종
   - 파일명: `엑셀단가표_YYYYMMDD_HHMMSS.xlsx`
7. **행 추가**: 빈 행 추가 → DB 저장 → 테이블 리렌더 → 품명 셀 자동 포커스
8. **행 삭제** (NO 컬럼 통합): NO 셀 호버 시 × 표시 → 클릭 → confirm → 삭제
9. **전체 삭제**: 모든 데이터 삭제
10. XSS 방지: HTML 이스케이프 처리

**행 추가/삭제 흐름**:
```
[행 추가] 클릭 → 빈 항목 생성 (기본값: 새 항목) → DB 저장 → 테이블 리렌더 → 품명 셀 자동 포커스
NO 셀 호버 → × 표시 → 클릭 → confirm → DB 삭제 → 행 제거 → 번호 재정렬
```

**편집 흐름 (인라인)**:
```
셀 클릭 → input 삽입 (셀 크기 고정) → 값 수정 → blur/Enter
  → updateImportedUnitPrice(id, { field: newValue })
  → 합계 자동 재계산 (자재비/노무비 변경 시)
  → 품명/규격/부위 변경 시 테이블 리렌더 (그룹핑 반영)
  → 그 외 해당 셀만 갱신
```

**UI 톤**: 회색 계열 통일 (헤더 #334155, 버튼 #475569/#64748b, 테이블 #f1f5f9/#e2e8f0)

**모달 패턴**: 기존 `openUnitPriceManagement()` (unitPriceManager.js:494-573) 패턴 참조

---

### Phase 5: 엑셀 벽체타입 관리 모달

**파일**: `public/js/modules/excelWallTypeManager.js` (신규)

**작업 내용**:
1. `openExcelWallTypeModal()` → 메인 모달
2. 벽체타입 목록 테이블 — **기존 `revitTypeMatching.js`와 동일한 컬럼 구조**:
   ```
   [체크] | No | WallType | 좌측마감(Layer3,Layer2,Layer1) | 구조체 | 단열재 | 우측마감(Layer1,Layer2,Layer3) | 옵션1~4 | 두께(mm) | [+추가컬럼...]
   ```
3. 각 레이어 셀: 드롭다운으로 `importedUnitPrices` 항목 선택
4. [+ 새 벽체타입] 버튼 → 새 행 추가
5. [+ 컬럼 추가] 버튼 → 12개 초과 시 동적 컬럼 추가 (extraLayers)
6. 선택 시 자재비/노무비 자동 표시, 두께 자동 합산
7. CRUD: 생성, 수정, 삭제
8. `excelWallTypes` 테이블에 저장

**기본 12개 레이어 컬럼** (항상 표시, 삭제 불가):
| 위치 | 필드명 | 컬럼명 |
|------|--------|--------|
| 좌측마감 | `layer3_1`, `layer2_1`, `layer1_1` | Layer3, Layer2, Layer1 |
| 중앙 | `column1`, `infill` | 구조체, 단열재 |
| 우측마감 | `layer1_2`, `layer2_2`, `layer3_2` | Layer1, Layer2, Layer3 |
| 옵션 | `column2`, `channel`, `runner`, `steelPlate` | 옵션1~4 |

**동적 컬럼**: 12개 초과 시 `[+]` 버튼으로 추가, `[×]` 버튼으로 삭제 가능

**UI 일관성**: 기존 벽체타입 관리 모달(`revitTypeMatching.js`)과 **동일한 테이블 헤더/레이아웃** 사용

---

### Phase 6: 계산 로직 완전 분리 ✅

**파일**: `public/js/wall-cost-calculator.js`, `public/index.html`

**핵심 원칙**: 두 계산 방식을 **완전히 분리**. 중복 계산 방지.

---

#### 6.1 UI 변경 — 별도 계산 버튼 추가 ✅

**위치**: Revit 벽체 데이터 확인 섹션의 필터 컨트롤 영역

```
기존:
[계산하기]

변경 후:
[일위대가 계산] [엑셀 계산]
```

| 버튼 | ID | 함수 | 검색 대상 |
|------|-----|------|----------|
| 일위대가 계산 | `btnCalculateDetailed` | `calculateWallCostsDetailed()` | wallTypeMasters (KiyenoMaterialsDB) |
| 엑셀 계산 | `btnCalculateExcel` | `calculateWallCostsExcel()` | excelWallTypes (KiyenoExcelDB) |

---

#### 6.2 계산 함수 분리 ✅

**기존 `calculateWallCosts()` → 2개로 분리** (기존 함수는 호환성을 위해 유지)

```javascript
// 1. 일위대가 방식 계산 (기존 로직 유지)
window.calculateWallCostsDetailed = async function() {
  const selectedWalls = getSelectedRevitWalls();
  for (const wall of selectedWalls) {
    // wallTypeMasters에서만 검색
    const match = await findMatchingWallTypeDetailed(wall.Name);
    if (match) {
      const result = await calculateSingleWallCostDetailed(wall, match, seq);
      result.source = 'detailed';
      calculationResults.push(result);
    } else {
      // 미매칭 처리
    }
  }
  renderCalculationResults();
}

// 2. 엑셀 방식 계산 (신규)
window.calculateWallCostsExcel = async function() {
  const selectedWalls = getSelectedRevitWalls();
  for (const wall of selectedWalls) {
    // excelWallTypes에서만 검색
    const match = await findMatchingWallTypeExcel(wall.Name);
    if (match) {
      const result = calculateSingleWallCostExcel(wall, match, seq);
      result.source = 'excel';
      calculationResults.push(result);
    } else {
      // 미매칭 처리
    }
  }
  renderCalculationResults();
}
```

---

#### 6.3 매칭 함수 분리 ✅

```javascript
// 일위대가 전용 매칭 (기존 wallTypeMasters만)
async function findMatchingWallTypeDetailed(wallTypeName) {
  // window.revitWallTypes (벽체 타입 관리)에서만 검색
  // excelWallTypes는 검색하지 않음!
}

// 엑셀 전용 매칭 (KiyenoExcelDB만)
async function findMatchingWallTypeExcel(wallTypeName) {
  const excelWallTypes = await ExcelUnitPriceImporter.getAllExcelWallTypes();
  return excelWallTypes.find(wt => wt.name === wallTypeName);
  // wallTypeMasters는 검색하지 않음!
}
```

---

#### 6.4 엑셀 방식 계산 로직 ✅

```javascript
function calculateSingleWallCostExcel(wall, excelWallType, sequence) {
  const area = Math.round((parseFloat(wall.Area) || 0) * 100) / 100;

  // 엑셀 벽체타입에 저장된 M2당 단가 사용
  const materialUnitPrice = excelWallType.totalMaterialPrice || 0;
  const laborUnitPrice = excelWallType.totalLaborPrice || 0;
  const unitPrice = materialUnitPrice + laborUnitPrice;

  return {
    wallId: wall.id,
    wallName: wall.Name,
    area: area,
    wallType: excelWallType,
    materialCost: Math.round(area * materialUnitPrice),
    laborCost: Math.round(area * laborUnitPrice),
    totalCost: area * unitPrice,
    source: 'excel',
    layerPricing: {}  // 엑셀 방식은 레이어별 상세 없음
  };
}
```

---

#### 6.5 결과 표시 — 공통 사용 ✅

두 계산 방식 모두 **동일한 결과 화면** 사용 (`renderCalculationResults()`).

- 결과에 `source` 필드로 계산 방식 표시
- 시각적 배지: "엑셀" / "일위대가"
- 결과 병합 가능 (두 버튼 순차 클릭 시 누적)

---

#### 6.6 결과 초기화 ✅

**계산 버튼 클릭 시 동작**:
- 같은 버튼 재클릭: 해당 source 결과만 **대체** (다른 source 유지)
- 다른 버튼 클릭: 기존 결과에 **추가** (병합)

예시:
```
[일위대가 계산] 클릭 → W-01, W-02 계산됨 (source: 'detailed')
[엑셀 계산] 클릭 → W-03, W-04 계산됨 (source: 'excel')
결과 화면: W-01, W-02, W-03, W-04 모두 표시
```

---

### Phase 7: 결과 표시 확장 (진행 예정)

**파일**: `public/js/wall-cost-calculator.js`

---

#### 7.1 단가비교표 탭

- 두 방식 벽체 모두 **동일 형식**으로 표시
- source 배지로 구분 ("엑셀" / "일위대가")
- 자재비/노무비/합계 컬럼 표시

---

#### 7.2 발주서 탭

| 항목 | 처리 |
|------|------|
| 일위대가 방식 | 정상 표시 (구성품별 상세) |
| 엑셀 방식 | **제외** + 알림 배너 표시 |

**알림 배너 UI**:
```
┌─────────────────────────────────────────────────────────┐
│ ⚠️ 엑셀 단가 적용 벽체 (발주서 미지원)                     │
│ 다음 벽체는 상세 구성품 정보가 없어 발주서에 포함되지 않음: │
│ - W-01: 150.5㎡, 2,067,027원                            │
│ - W-03: 85.3㎡, 1,250,000원                             │
│ (단가비교표에서 금액 확인 가능)                           │
└─────────────────────────────────────────────────────────┘
```

---

#### 7.3 견적서 탭

- 갑지 (표지): 총 금액에 **엑셀 방식 포함**
- 을지 (내역서): 합계만 표시 (구성품 상세 없음)

---

## index.html에 스크립트 로드 추가

**파일**: `public/index.html`

3개 신규 JS 파일을 `<script>` 태그로 추가:
```html
<script src="/js/modules/excelUnitPriceImporter.js"></script>
<script src="/js/modules/excelPriceManager.js"></script>
<script src="/js/modules/excelWallTypeManager.js"></script>
```

---

## 수정 파일 목록 요약

| 파일 | 작업 | Phase |
|------|------|-------|
| `public/index.html` | 버튼 2개 + 라벨 추가, 스크립트 로드, 계산 버튼 분리 | 1 ✅, 6 ✅ |
| `public/css/styles.css` | 섹션 라벨/구분선 스타일 | 1 ✅ |
| `public/js/modules/excelUnitPriceImporter.js` | **신규** - 별도 DB(`KiyenoExcelDB`) + 엑셀 파싱/DB CRUD | 2 ✅, 3 ✅ |
| `public/js/modules/excelPriceManager.js` | **신규** - 엑셀 단가표 관리 모달 | 4 ✅ |
| `public/js/modules/excelWallTypeManager.js` | **신규** - 엑셀 벽체타입 관리 모달 + Revit 생성 | 5 ✅, 8, 9 |
| `public/js/wall-cost-calculator.js` | 계산 함수 분리 + 비교표 확장 | 6 ✅, 7 |
| `public/js/modules/priceComparisonManager.js` | 단가비교표 품명 버튼 + 자재별 벽체 검색 | 10 |
| `public/js/revit-wall-handler.js` | 색상 생성 유틸리티 함수 (선택적) | 10 |

## 수정하지 않는 파일 (완벽 분리)

| 파일 | 이유 |
|------|------|
| `priceDatabase.js` | 기존 DB(`KiyenoMaterialsDB` v3) 전용 — 별도 DB 사용으로 수정 불필요 |
| `unitPriceManager.js` (일위대가 관리 로직) | 기존 상세 일위대가 전용 |
| `materialManager.js` | 기존 자재 관리 전용 |
| `revitTypeMatching.js` | 기존 벽체타입 관리 전용 |

---

### Phase 8: 엑셀 벽체타입 내보내기/불러오기

**파일**: `public/js/modules/excelWallTypeManager.js` (기존 파일에 추가)

**방식**: 2시트 Excel 파일 (사용자용 + 매핑데이터)

---

#### 8.1 UI 변경 — 툴바에 버튼 2개 추가

**위치**: `buildModalHTML()` 함수의 상단 툴바 영역

기존 `[선택 삭제]` 버튼 뒤에 구분선 + 2개 버튼 추가:

```
[새 벽체타입] [컬럼 추가] | [선택 삭제] | [엑셀 내보내기] [엑셀 불러오기]     좌클릭: 레이어 선택 | 우클릭: 레이어 해제
```

- `[엑셀 내보내기]` (id: `btnExportWallTypes`, 아이콘: `fa-file-download`)
- `[엑셀 불러오기]` (id: `btnImportWallTypes`, 아이콘: `fa-file-upload`)

---

#### 8.2 내보내기 (Export) — `handleExportWallTypes()`

**출력 파일명**: `엑셀벽체타입_YYYYMMDD_HHMMSS.xlsx`

**시트 1: "벽체타입" (사용자용)**

컬럼 순서는 `getOrderedColumnList()`와 동일한 순서:

```
WallType | 좌-Layer3 | 좌-Layer2 | 좌-Layer1 | [추가컬럼...] | 구조체 | [추가컬럼...] | 단열재 | [추가컬럼...] | 우-Layer1 | 우-Layer2 | 우-Layer3 | [추가컬럼...] | 옵션1 | 옵션2 | 옵션3 | 옵션4 | [추가컬럼...] | 두께 | 자재비 | 노무비 | 합계
```

- 레이어 셀: `"품명 규격"` 형식 (`getUnitPriceDisplayText(id)` 사용)
- 빈 레이어: 빈 셀
- 삭제된 단가: `"(삭제됨)"`
- 두께/자재비/노무비/합계: 숫자 값

**시트 2: "매핑데이터" (시스템용, 불러오기 시 사용)**

동일한 컬럼 순서이되, 셀 값이 다름:

- **1행 (메타데이터 행)**: 컬럼 식별자
  - 기본 컬럼: 필드명 (예: `layer3_1`, `column1`, `infill`)
  - 추가 컬럼: `extra_0`, `extra_1`, ...
  - 첫 번째 셀: `"_wallTypeName"`
  - 마지막 4셀: `"_thickness"`, `"_materialPrice"`, `"_laborPrice"`, `"_totalPrice"`

- **2행 (추가 컬럼 메타데이터)**: 추가 컬럼에만 의미 있음
  - 기본 컬럼 셀: 빈 값
  - 추가 컬럼 셀: `"label:구조체2,insertAfter:column1"` (콤마 구분 키:값)
  - WallType 셀: `"_extraMeta"`

- **3행~ (데이터)**: 벽체타입별 매핑 데이터
  - WallType 셀: 벽체타입 이름
  - 레이어 셀: `unitPriceKey` (예: `c-stud_65형`)
  - 두께/자재비/노무비/합계: 빈 셀 (불러오기 시 자동 재계산)

---

#### 8.3 불러오기 (Import) — `handleImportWallTypes()`

**입력**: `.xlsx` 파일 (위 내보내기 형식)

**매칭 우선순위**:
1. **시트2 key 매칭** (최우선): 셀의 `unitPriceKey` → `getImportedUnitPriceByKey(key)` → ID 획득
2. **매칭 실패 시**: 해당 레이어 빈 값으로 설정, 실패 목록에 추가

**벽체타입 매칭 (upsert by name)**:
- 이름 일치: 기존 벽체타입 업데이트
- 이름 불일치: 새 벽체타입 생성
- 기존에만 존재: 삭제하지 않음 (유지)

**추가 컬럼 처리**:
- 시트2 1행에서 `extra_N` 컬럼 감지
- 시트2 2행에서 `label`, `insertAfter` 메타데이터 파싱
- Excel에 있고 DB에 없는 컬럼 → 모든 벽체타입에 추가
- Excel에 없고 DB에만 있는 컬럼 → 유지

**결과 리포트** (토스트):
```
불러오기 완료: 업데이트 N개, 신규 생성 N개, 매칭 실패 레이어 N개
```

---

#### 8.4 이벤트 바인딩

`bindModalEvents()` 함수에 추가:

```javascript
document.getElementById('btnExportWallTypes')?.addEventListener('click', handleExportWallTypes);
document.getElementById('btnImportWallTypes')?.addEventListener('click', handleImportWallTypes);
```

---

#### 8.5 핵심 함수 목록

| 함수명 | 역할 |
|--------|------|
| `handleExportWallTypes()` | 내보내기 메인 함수 |
| `buildExportSheet1(orderedColumns)` | 시트1 데이터 생성 (사용자용) |
| `buildExportSheet2(orderedColumns)` | 시트2 데이터 생성 (매핑용) |
| `handleImportWallTypes()` | 불러오기 메인 함수 |
| `parseImportSheet2(ws)` | 시트2 파싱 (메타데이터 + 데이터) |
| `matchUnitPriceByKey(key)` | key로 importedUnitPrice 매칭 |

**의존성**: SheetJS (이미 index.html에 포함), `ExcelUnitPriceImporter.getImportedUnitPriceByKey()`

---

### Phase 9: Revit 벽체타입 생성 기능

**파일**: `public/js/modules/excelWallTypeManager.js` (기존 파일에 추가)

**기존 기능 참조**: `public/js/modules/revitTypeMatching.js`의 `showWallTypePreview()` (라인 2024-2164)

---

#### 9.1 UI 변경 — 툴바 버튼 + 상태바 업데이트

**위치**: `buildModalHTML()` 함수의 상단 툴바 영역

기존 `[엑셀 불러오기]` 버튼 뒤에 구분선 + 버튼 추가:

```
[새 벽체타입] [컬럼 추가] | [선택 삭제] | [엑셀 내보내기] [엑셀 불러오기] | [Revit 생성]     좌클릭: 레이어 선택 | 우클릭: 레이어 해제
```

- `[Revit 생성]` (id: `btnCreateRevitWallTypes`, 아이콘: `fa-cube`, 색상: `#2563eb` 파란색)

**상태바 업데이트**:
- 기존 상태바 좌측에 Revit 연결 상태 표시: `● Revit 연결됨` (초록) / `○ Revit 미연결` (회색)
- 체크된 벽체타입 수 표시: `선택: N개`

---

#### 9.2 이벤트 바인딩

`bindModalEvents()` 함수에 추가:

```javascript
document.getElementById('btnCreateRevitWallTypes')?.addEventListener('click', handleCreateRevitWallTypes);
```

---

#### 9.3 핵심 함수 4개

**함수 1: `getExcelLayerStructure(wallType)`** — 동기 함수

기존 `revitTypeMatching.js`의 `getLayerStructure()` (비동기, materialId 조회) 대신,
로컬 `unitPriceMap` 캐시를 사용하는 동기 버전.

```javascript
// 입력: excelWallType 객체
// 출력: { wallTypeName, layers[], totalThickness, errors[], hasErrors }

// 처리 흐름:
// 1. getOrderedColumnList()로 전체 컬럼 목록 획득 (12개 기본 + extras)
// 2. 각 컬럼에서 unitPriceId 추출 (기본: wt[col.field], extras: extraLayers 배열)
// 3. unitPriceMap[id]로 품명/규격/두께 조회
// 4. 비어있는 레이어 건너뛰기
// 5. 삭제된 단가(unitPriceMap에 없음) → errors 배열에 추가

// layers 배열 요소:
{
  position: '좌측마감 - Layer3',  // 그룹명 + 라벨 (C# 애드인이 구분용)
  materialName: 'C-STUD',        // 품명
  spec: '65형',                   // 규격
  thickness: 65,                  // 두께 (mm)
  isUnitPrice: true               // 항상 true (엑셀 방식)
}
```

**기존 getLayerStructure()와 차이점**:
| 항목 | 기존 (revitTypeMatching.js) | 신규 (excelWallTypeManager.js) |
|------|---------------------------|-------------------------------|
| 실행 방식 | async (DB 조회) | sync (unitPriceMap 캐시) |
| 레이어 수 | 7개 고정 위치 | 12개 기본 + extraLayers 동적 |
| position 형식 | `layer3_1`, `column1` 등 | `좌측마감 - Layer3`, `중앙 - 구조체` 등 |
| materialId | materialId 또는 unitPriceId | importedUnitPriceId (항상) |
| isUnitPrice | true/false | 항상 true |

---

**함수 2: `buildExcelLayerPreviewHTML(wallTypesData)`** — 미리보기 HTML 생성

`createSubModal()`에 표시할 미리보기 HTML 생성.

```
┌─────────────────────────────────────────────┐
│  Revit 벽체타입 생성 미리보기                    │
│                                              │
│  ✅ W-01 (두께: 120mm, 레이어: 5개)            │
│  ┌──────────┬──────────┬────────┐           │
│  │ 위치      │ 품명/규격  │ 두께   │           │
│  ├──────────┼──────────┼────────┤           │
│  │ 좌-Layer1│ C-STUD 65│ 65mm   │           │
│  │ 구조체    │ C-STUD 65│ 65mm   │           │
│  │ ...      │ ...      │ ...    │           │
│  └──────────┴──────────┴────────┘           │
│                                              │
│  ❌ W-03 (오류: 삭제된 단가 2개)               │
│  - 구조체: 단가 데이터 없음                     │
│  - 단열재: 단가 데이터 없음                     │
│                                              │
│  총 5개 중 4개 생성 가능, 1개 오류              │
│                                              │
│              [취소]  [생성하기 (4개)]           │
└─────────────────────────────────────────────┘
```

- 오류 있는 벽체: 빨간색 표시, 생성 대상에서 제외
- 오류 없는 벽체: 초록 체크 + 레이어 테이블 표시
- 하단 요약: 생성 가능/오류 수

---

**함수 3: `handleCreateRevitWallTypes()`** — 메인 진입점

```
[Revit 생성] 클릭
  → 선택된 벽체 확인 (selectedWallTypes.size)
  → 선택 없으면 alert('벽체타입을 선택해 주세요.')
  → 각 선택 벽체에 getExcelLayerStructure() 호출
  → buildExcelLayerPreviewHTML()로 미리보기 HTML 생성
  → createSubModal('Revit 벽체타입 생성', html, buttons)
     - buttons: [
         { text: '취소', className: 'btn-secondary', onClick: close },
         { text: '생성하기 (N개)', className: 'btn-blue', onClick: sendExcelWallTypesToRevit }
       ]
  → 유효한 벽체 0개면 생성 버튼 비활성화
```

---

**함수 4: `sendExcelWallTypesToRevit(validWallTypes, totalCount)`** — Revit 전송

```javascript
// 1. 연결 확인
if (!window.socketService?.isConnected) {
  alert('서버에 연결되어 있지 않습니다.');
  return;
}
if (!window.socketService?.revitConnected) {
  alert('Revit이 연결되어 있지 않습니다.');
  return;
}

// 2. PascalCase JSON 변환 (기존 revitTypeMatching.js:2090-2101 형식 동일)
const revitData = validWallTypes.map(wallData => ({
  WallTypeName: wallData.wallTypeName,
  TotalThickness: wallData.totalThickness,
  Layers: wallData.layers.map(layer => ({
    Position: layer.position,
    MaterialId: '',              // 엑셀 방식은 materialId 없음
    MaterialName: layer.materialName,
    Specification: layer.spec,
    Thickness: layer.thickness,
    IsUnitPrice: true
  }))
}));

// 3. 전송
window.socketService.sendRevitCommand('CREATE_WALL_TYPES', revitData);

// 4. 토스트 알림
showToast(`Revit으로 ${validWallTypes.length}개 벽체타입 전송 중...`, 'info');
```

**결과 처리**: 기존 `revitTypeMatching.js`의 `revit:wallTypeResult` 전역 리스너 재사용.
- 이미 `window.showWallTypeCreationResult`로 전역 등록되어 있음
- 별도 리스너 추가 불필요

---

#### 9.4 상태바 Revit 연결 상태 표시

`updateStatusBar()` 함수 수정:

```javascript
// 기존: '총 N개 벽체타입'
// 변경: 'Revit: ● 연결됨 | 선택: 3개 | 총 N개 벽체타입'
const revitStatus = window.socketService?.revitConnected
  ? '<span style="color:#22c55e">● Revit 연결됨</span>'
  : '<span style="color:#9ca3af">○ Revit 미연결</span>';

const selectionCount = selectedWallTypes.size;
const selectionText = selectionCount > 0 ? `선택: ${selectionCount}개 | ` : '';
```

---

#### 9.5 오류 처리 매트릭스

| 상황 | 처리 |
|------|------|
| 벽체 미선택 | `alert('벽체타입을 선택해 주세요.')` |
| 모든 벽체 오류 | 미리보기에서 생성 버튼 비활성화 + 안내 메시지 |
| 일부 벽체 오류 | 오류 벽체 제외, 유효한 것만 생성 |
| 서버 미연결 | `alert('서버에 연결되어 있지 않습니다.')` |
| Revit 미연결 | `alert('Revit이 연결되어 있지 않습니다.')` |
| 삭제된 단가 참조 | 해당 레이어 오류 표시, 벽체 생성 제외 |

---

#### 9.6 핵심 함수 목록

| 함수명 | 역할 |
|--------|------|
| `getExcelLayerStructure(wallType)` | 벽체타입 → 레이어 구조 변환 (동기) |
| `buildExcelLayerPreviewHTML(wallTypesData)` | 미리보기 모달 HTML 생성 |
| `handleCreateRevitWallTypes()` | Revit 생성 메인 함수 |
| `sendExcelWallTypesToRevit(validWallTypes, totalCount)` | Revit WebSocket 전송 |

**의존성**: `window.socketService` (sendRevitCommand, isConnected, revitConnected), `window.createSubModal`, `window.showToast`

---

### Phase 10: 단가비교표 자재별 Revit 벽체 3D 뷰 색상 표시 기능

**파일**: `public/js/modules/priceComparisonManager.js`, `public/js/revit-wall-handler.js`

**기능 개요**:
단가비교표의 각 자재 품명 옆에 버튼을 추가하여, 해당 자재가 포함된 Revit 벽체를 찾아 3D 뷰에서 색상으로 표시

---

#### 10.1 기능 요구사항

1. **자재별 벽체 검색**: 특정 자재(예: C-STUD 65형)가 포함된 모든 Revit 벽체 찾기
2. **3D 뷰 복제**: 현재 활성화된 3D 뷰를 복제 (뷰 이름: 자재 품명, 예: "C-STUD 65형")
3. **색상 오버라이드**: 복제된 3D 뷰에서 해당 벽체들에 색상 적용
4. **UI**: 단가비교표의 품명 컬럼에 버튼 추가

---

#### 10.2 기존 기능 분석

**기존 색상 오버라이드 기능** (`revit-wall-handler.js`):
- `window.applyWallColors()` (라인 1961) — 선택된 벽체에 색상 적용
- `window.clearWallColors()` (라인 2137) — 색상 초기화
- `window.createLegendView()` (라인 2186) — 범례 뷰 생성
- WebSocket 명령: `APPLY_WALL_COLORS`, `CLEAR_WALL_COLORS`, `CREATE_LEGEND_VIEW`
- `wallColorMap` — 벽체별 색상 매핑 저장

**단가비교표 렌더링** (`priceComparisonManager.js`):
- `renderDetailItems()` (라인 487-530) — 자재비/노무비 항목 렌더링
- 라인 506: `<td>${item.itemName}</td>` — 품명 컬럼 (버튼 추가 위치)
- 데이터 구조: `priceComparisonData.detailSections.materials[]`, `labor[]`

**미구현 기능**:
- ❌ 3D 뷰 복제 — **신규 WebSocket 명령 필요**

---

#### 10.3 데이터 흐름

```
1. 계산 결과에서 자재가 포함된 벽체 찾기
   ┌─────────────────────────────────────────────────────────────┐
   │ calculationResults[]                                        │
   │ └── wallType.layers[] 또는 layerPricing                     │
   │     └── 각 레이어의 itemName === "C-STUD 65형"?             │
   │         → 해당 벽체의 ElementId 수집                         │
   └─────────────────────────────────────────────────────────────┘

2. Revit에 3D 뷰 복제 + 색상 오버라이드 요청
   ┌─────────────────────────────────────────────────────────────┐
   │ WebSocket 명령: DUPLICATE_3D_VIEW_WITH_COLOR                │
   │ {                                                           │
   │   viewName: "C-STUD 65형",                                  │
   │   elementIds: [123456, 234567, ...],                        │
   │   color: { r: 255, g: 100, b: 100 }                         │
   │ }                                                           │
   └─────────────────────────────────────────────────────────────┘

3. Revit C# 애드인 처리 (구현 필요)
   ┌─────────────────────────────────────────────────────────────┐
   │ 1. 현재 활성 3D 뷰 복제                                      │
   │ 2. 복제된 뷰 이름을 viewName으로 설정                        │
   │ 3. 복제된 뷰에서 지정된 elementIds에 색상 오버라이드 적용     │
   │ 4. 복제된 뷰로 전환 (활성화)                                 │
   └─────────────────────────────────────────────────────────────┘
```

---

#### 10.4 UI 변경 — 단가비교표 품명 버튼

**위치**: `priceComparisonManager.js` → `renderDetailItems()` 함수 (라인 506)

**변경 전**:
```javascript
<td>${item.itemName}</td>
```

**변경 후**:
```javascript
<td>
  ${item.itemName}
  <button class="btn-view-material-walls"
          data-item-name="${escapeHtml(item.itemName)}"
          data-item-spec="${escapeHtml(item.spec || '')}"
          title="이 자재가 사용된 벽체를 3D 뷰에서 색상으로 표시">
    <i class="fas fa-cube"></i>
  </button>
</td>
```

**버튼 스타일** (인라인 또는 CSS 추가):
```css
.btn-view-material-walls {
  margin-left: 6px;
  padding: 2px 6px;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
}
.btn-view-material-walls:hover {
  background: #1d4ed8;
}
.btn-view-material-walls:disabled {
  background: #9ca3af;
  cursor: not-allowed;
}
```

---

#### 10.5 핵심 함수 구현

**함수 1: `findWallsByMaterial(itemName, spec)`**

위치: `priceComparisonManager.js` 또는 `wall-cost-calculator.js`

```javascript
/**
 * 특정 자재가 포함된 벽체의 ElementId 목록 반환
 * @param {string} itemName - 품명 (예: "C-STUD")
 * @param {string} spec - 규격 (예: "65형")
 * @returns {Array<string>} ElementId 배열
 */
function findWallsByMaterial(itemName, spec) {
  const matchingWalls = [];

  // calculationResults에서 검색
  for (const result of calculationResults) {
    let hasMaterial = false;

    // 일위대가 방식: layerPricing 검색
    if (result.source === 'detailed' && result.layerPricing) {
      for (const layer of Object.values(result.layerPricing)) {
        if (layer.items) {
          for (const item of layer.items) {
            if (item.itemName === itemName && (!spec || item.spec === spec)) {
              hasMaterial = true;
              break;
            }
          }
        }
        if (hasMaterial) break;
      }
    }

    // 엑셀 방식: wallType.layers 또는 excelWallType 필드 검색
    if (result.source === 'excel' && result.wallType) {
      // excelWallType의 레이어 정보에서 검색
      // (unitPriceMap 캐시 활용)
    }

    if (hasMaterial && result.wallId) {
      matchingWalls.push(result.wallId);
    }
  }

  return matchingWalls;
}
```

---

**함수 2: `handleViewMaterialWalls(itemName, spec)`**

위치: `priceComparisonManager.js`

```javascript
/**
 * 자재별 벽체 3D 뷰 색상 표시 버튼 클릭 핸들러
 */
async function handleViewMaterialWalls(itemName, spec) {
  // 1. 연결 상태 확인
  if (!window.socketService?.isConnected) {
    alert('서버에 연결되어 있지 않습니다.');
    return;
  }
  if (!window.socketService?.revitConnected) {
    alert('Revit이 연결되어 있지 않습니다.');
    return;
  }

  // 2. 해당 자재가 포함된 벽체 찾기
  const elementIds = findWallsByMaterial(itemName, spec);

  if (elementIds.length === 0) {
    alert(`"${itemName} ${spec || ''}"이(가) 포함된 벽체가 없습니다.`);
    return;
  }

  // 3. 컬러 피커 모달 표시
  showColorPickerModal(itemName, spec, elementIds);
}
```

---

**함수 3: `showColorPickerModal(itemName, spec, elementIds)`**

위치: `priceComparisonManager.js`

```javascript
/**
 * 컬러 피커 모달 표시
 * @param {string} itemName - 품명
 * @param {string} spec - 규격
 * @param {Array} elementIds - 적용할 벽체 ElementId 배열
 */
function showColorPickerModal(itemName, spec, elementIds) {
  const viewName = spec ? `${itemName} ${spec}` : itemName;

  const modalHTML = `
    <div style="padding: 20px; text-align: center;">
      <p style="margin-bottom: 15px; font-size: 14px;">
        <strong>${viewName}</strong> (${elementIds.length}개 벽체)
      </p>
      <div style="margin-bottom: 20px;">
        <label style="font-size: 13px; color: #64748b;">색상 선택:</label>
        <input type="color" id="materialColorPicker" value="#ff6b6b"
               style="width: 80px; height: 40px; cursor: pointer; border: 1px solid #cbd5e1; border-radius: 4px;">
      </div>
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button id="btnCancelColor" class="btn btn-secondary" style="padding: 8px 20px;">취소</button>
        <button id="btnApplyColor" class="btn btn-blue" style="padding: 8px 20px;">적용</button>
      </div>
    </div>
  `;

  const modal = window.createSubModal(`3D 뷰 색상 표시: ${viewName}`, modalHTML);

  // 이벤트 바인딩
  document.getElementById('btnCancelColor')?.addEventListener('click', () => modal.close());
  document.getElementById('btnApplyColor')?.addEventListener('click', () => {
    const colorInput = document.getElementById('materialColorPicker');
    const hexColor = colorInput.value;
    const rgb = hexToRgb(hexColor);

    // Revit 명령 전송
    window.socketService.sendRevitCommand('DUPLICATE_3D_VIEW_WITH_COLOR', {
      viewName: viewName,
      elementIds: elementIds,
      color: rgb
    });

    showToast(`${viewName}: ${elementIds.length}개 벽체 색상 표시 중...`, 'info');
    modal.close();
  });
}

/**
 * HEX → RGB 변환
 */
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : { r: 255, g: 100, b: 100 };
}
```

---

#### 10.6 이벤트 바인딩

`priceComparisonManager.js`에서 이벤트 위임 방식으로 버튼 클릭 처리:

```javascript
// renderPriceComparisonTable() 또는 초기화 함수에서
document.addEventListener('click', (e) => {
  const btn = e.target.closest('.btn-view-material-walls');
  if (btn) {
    const itemName = btn.dataset.itemName;
    const spec = btn.dataset.itemSpec;
    handleViewMaterialWalls(itemName, spec);
  }
});
```

---

#### 10.7 Revit C# 애드인 수정 (참고)

**신규 WebSocket 명령 핸들러** (C# 구현 필요):

```csharp
case "DUPLICATE_3D_VIEW_WITH_COLOR":
    // 1. 현재 활성 3D 뷰 가져오기
    View3D activeView = doc.ActiveView as View3D;
    if (activeView == null) {
        SendError("활성화된 3D 뷰가 없습니다.");
        return;
    }

    // 2. 뷰 복제
    ElementId newViewId = activeView.Duplicate(ViewDuplicateOption.Duplicate);
    View3D newView = doc.GetElement(newViewId) as View3D;
    newView.Name = data.viewName;  // "C-STUD 65형"

    // 3. 색상 오버라이드 설정
    OverrideGraphicSettings ogs = new OverrideGraphicSettings();
    ogs.SetSurfaceForegroundPatternColor(new Color(data.color.r, data.color.g, data.color.b));
    ogs.SetSurfaceForegroundPatternId(solidFillPatternId);

    // 4. 지정된 ElementId에 오버라이드 적용
    foreach (string idStr in data.elementIds) {
        ElementId elemId = new ElementId(int.Parse(idStr));
        newView.SetElementOverrides(elemId, ogs);
    }

    // 5. 복제된 뷰로 전환
    uidoc.ActiveView = newView;

    // 6. 응답 전송
    SendResponse("VIEW_CREATED", new { viewName = newView.Name, elementCount = data.elementIds.Length });
    break;
```

---

#### 10.8 핵심 함수 목록

| 함수명 | 위치 | 역할 |
|--------|------|------|
| `findWallsByMaterial(itemName, spec)` | priceComparisonManager.js | 자재 포함 벽체 검색 |
| `handleViewMaterialWalls(itemName, spec)` | priceComparisonManager.js | 버튼 클릭 핸들러 |
| `showColorPickerModal(itemName, spec, elementIds)` | priceComparisonManager.js | 컬러 피커 모달 표시 |
| `hexToRgb(hex)` | priceComparisonManager.js | HEX → RGB 변환 |

**의존성**:
- `window.socketService` (sendRevitCommand, isConnected, revitConnected)
- `window.calculationResults` (계산 결과 배열)
- `window.showToast` (토스트 알림)

---

#### 10.9 오류 처리

| 상황 | 처리 |
|------|------|
| 서버 미연결 | `alert('서버에 연결되어 있지 않습니다.')` |
| Revit 미연결 | `alert('Revit이 연결되어 있지 않습니다.')` |
| 해당 자재 벽체 없음 | `alert('"품명"이(가) 포함된 벽체가 없습니다.')` |
| 활성 3D 뷰 없음 | Revit에서 오류 응답 → 토스트로 표시 |
| 뷰 복제 실패 | Revit에서 오류 응답 → 토스트로 표시 |

---

#### 10.10 향후 확장 가능성

1. **다중 자재 선택**: 체크박스로 여러 자재 선택 후 한 번에 색상 표시
2. **범례 자동 생성**: 뷰에 자재별 색상 범례 추가
3. **뷰 관리**: 생성된 뷰 목록 표시 및 삭제 기능
4. **최근 사용 색상**: 컬러 피커에 최근 선택 색상 프리셋 표시

---

## 검증 방법

1. **UI 테스트**: 메인 화면에서 섹션 라벨과 5개 버튼 정상 표시 확인
2. **엑셀 업로드 테스트**: 엑셀 파일 업로드 → importedUnitPrices 저장 → 재업로드 시 upsert 확인
3. **단가표 관리 테스트**: 목록 표시, 검색, 수정, 삭제, 전체 삭제
4. **벽체타입 관리 테스트**: 생성, 레이어 선택, 합계 자동 계산, 저장
5. **계산 버튼 UI 테스트**: [일위대가 계산] [엑셀 계산] 버튼 2개 표시 확인
6. **일위대가 계산 테스트**: [일위대가 계산] 클릭 → wallTypeMasters 기반 벽체만 계산 확인
7. **엑셀 계산 테스트**: [엑셀 계산] 클릭 → excelWallTypes 기반 벽체만 계산 확인
8. **계산 분리 테스트**: 두 버튼 순차 클릭 → 결과가 병합되어 표시 확인
9. **source 구분 테스트**: 계산 결과에 source='detailed'/'excel' 필드 확인
10. **비교표 테스트**: 두 방식 벽체 모두 단가비교표에 표시
11. **IndexedDB 확인**: 개발자도구 > Application > IndexedDB에서 2개 신규 테이블 데이터 확인
12. **벽체타입 내보내기 테스트**: 벽체타입 생성 후 내보내기 → Excel 파일에 2개 시트 확인
13. **벽체타입 불러오기 테스트**: 내보낸 파일 불러오기 → 기존 벽체타입 업데이트 확인
14. **매칭 실패 테스트**: 단가표에 없는 key가 포함된 파일 불러오기 → 매칭 실패 리포트 확인
15. **Revit 생성 버튼 테스트**: 엑셀 벽체타입 모달에서 [Revit 생성] 버튼 표시 확인
16. **Revit 미리보기 테스트**: 벽체타입 체크 후 [Revit 생성] → 미리보기 모달에 레이어 목록 표시 확인
17. **Revit 전송 테스트**: 미리보기에서 [생성하기] 클릭 → WebSocket으로 PascalCase JSON 전송 확인
18. **Revit 오류 테스트**: 삭제된 단가 참조 벽체 → 오류 표시 + 생성 대상 제외 확인
19. **Revit 연결 상태 테스트**: 상태바에 Revit 연결 상태 + 선택 개수 표시 확인
20. **단가비교표 버튼 테스트**: 자재비/노무비 품명 옆에 3D 뷰 버튼 표시 확인
21. **자재별 벽체 검색 테스트**: 버튼 클릭 → 해당 자재 포함 벽체 정확히 찾는지 확인
22. **3D 뷰 복제 테스트**: Revit에서 새 3D 뷰가 자재 이름으로 생성되는지 확인
23. **색상 오버라이드 테스트**: 복제된 뷰에서 해당 벽체만 색상 적용되는지 확인
24. **Revit 미연결 시 버튼 테스트**: 미연결 상태에서 버튼 클릭 → 경고 메시지 확인
